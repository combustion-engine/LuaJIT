/* automatically generated by rust-bindgen */

#![allow(dead_code, non_camel_case_types, non_upper_case_globals, non_snake_case)]

pub mod consts {
    pub const LUA_VERSION: &'static str = "Lua 5.1";
    pub const LUA_RELEASE: &'static str = "Lua 5.1.4";
    pub const LUA_VERSION_NUM: u32 = 501;
    pub const LUA_COPYRIGHT: &'static str = "Copyright (C) 1994-2008 Lua.org, PUC-Rio";
    pub const LUA_AUTHORS: &'static str = "R. Ierusalimschy, L. H. de Figueiredo & W. Celes";

    pub const LUAI_MAXSTACK: ::std::os::raw::c_int = 65500;
    pub const LUAI_MAXCSTACK: ::std::os::raw::c_int = 8000;
    pub const LUAI_GCPAUSE: ::std::os::raw::c_int = 200;
    pub const LUAI_GCMUL: ::std::os::raw::c_int = 200;
    pub const LUA_MAXCAPTURES: ::std::os::raw::c_int = 32;
    pub const LUA_IDSIZE: ::std::os::raw::c_int = 60;
    pub const LUAI_MAXNUMBER2STR: ::std::os::raw::c_int = 32;
    pub const LUA_MULTRET: ::std::os::raw::c_int = -1;
    pub const LUA_REGISTRYINDEX: ::std::os::raw::c_int = -10000;
    pub const LUA_ENVIRONINDEX: ::std::os::raw::c_int = -10001;
    pub const LUA_GLOBALSINDEX: ::std::os::raw::c_int = -10002;
    pub const LUA_OK: ::std::os::raw::c_int = 0;
    pub const LUA_YIELD: ::std::os::raw::c_int = 1;
    pub const LUA_ERRRUN: ::std::os::raw::c_int = 2;
    pub const LUA_ERRSYNTAX: ::std::os::raw::c_int = 3;
    pub const LUA_ERRMEM: ::std::os::raw::c_int = 4;
    pub const LUA_ERRERR: ::std::os::raw::c_int = 5;
    pub const LUA_TNONE: ::std::os::raw::c_int = -1;
    pub const LUA_TNIL: ::std::os::raw::c_int = 0;
    pub const LUA_TBOOLEAN: ::std::os::raw::c_int = 1;
    pub const LUA_TLIGHTUSERDATA: ::std::os::raw::c_int = 2;
    pub const LUA_TNUMBER: ::std::os::raw::c_int = 3;
    pub const LUA_TSTRING: ::std::os::raw::c_int = 4;
    pub const LUA_TTABLE: ::std::os::raw::c_int = 5;
    pub const LUA_TFUNCTION: ::std::os::raw::c_int = 6;
    pub const LUA_TUSERDATA: ::std::os::raw::c_int = 7;
    pub const LUA_TTHREAD: ::std::os::raw::c_int = 8;
    pub const LUA_MINSTACK: ::std::os::raw::c_int = 20;
    pub const LUA_GCSTOP: ::std::os::raw::c_int = 0;
    pub const LUA_GCRESTART: ::std::os::raw::c_int = 1;
    pub const LUA_GCCOLLECT: ::std::os::raw::c_int = 2;
    pub const LUA_GCCOUNT: ::std::os::raw::c_int = 3;
    pub const LUA_GCCOUNTB: ::std::os::raw::c_int = 4;
    pub const LUA_GCSTEP: ::std::os::raw::c_int = 5;
    pub const LUA_GCSETPAUSE: ::std::os::raw::c_int = 6;
    pub const LUA_GCSETSTEPMUL: ::std::os::raw::c_int = 7;
    pub const LUA_GCISRUNNING: ::std::os::raw::c_int = 9;
    pub const LUA_HOOKCALL: ::std::os::raw::c_int = 0;
    pub const LUA_HOOKRET: ::std::os::raw::c_int = 1;
    pub const LUA_HOOKLINE: ::std::os::raw::c_int = 2;
    pub const LUA_HOOKCOUNT: ::std::os::raw::c_int = 3;
    pub const LUA_HOOKTAILRET: ::std::os::raw::c_int = 4;
    pub const LUA_MASKCALL: ::std::os::raw::c_int = 1;
    pub const LUA_MASKRET: ::std::os::raw::c_int = 2;
    pub const LUA_MASKLINE: ::std::os::raw::c_int = 4;
    pub const LUA_MASKCOUNT: ::std::os::raw::c_int = 8;
    pub const LUAJIT_VERSION_NUM: ::std::os::raw::c_int = 20100;
    pub const LUAJIT_MODE_MASK: ::std::os::raw::c_int = 255;
    pub const LUAJIT_MODE_OFF: ::std::os::raw::c_int = 0;
    pub const LUAJIT_MODE_ON: ::std::os::raw::c_int = 256;
    pub const LUAJIT_MODE_FLUSH: ::std::os::raw::c_int = 512;
    pub const LUA_ERRFILE: ::std::os::raw::c_int = 6;
    pub const LUA_NOREF: ::std::os::raw::c_int = -2;
    pub const LUA_REFNIL: ::std::os::raw::c_int = -1;
}

pub type uintptr_t = usize;
pub type va_list = *mut ::std::os::raw::c_char;
pub type size_t = usize;
pub type ptrdiff_t = isize;
pub type intptr_t = isize;
pub type __vcrt_bool = u8;
pub type wchar_t = ::std::os::raw::c_ushort;
pub type max_align_t = f64;

pub enum lua_State {}

pub type lua_CFunction =
::std::option::Option<unsafe extern "C" fn(L: *mut lua_State)
                                           -> ::std::os::raw::c_int>;
pub type lua_Reader =
::std::option::Option<unsafe extern "C" fn(L: *mut lua_State,
                                           ud:
                                           *mut ::std::os::raw::c_void,
                                           sz: *mut size_t)
                                           -> *const ::std::os::raw::c_char>;
pub type lua_Writer =
::std::option::Option<unsafe extern "C" fn(L: *mut lua_State,
                                           p:
                                           *const ::std::os::raw::c_void,
                                           sz: size_t,
                                           ud:
                                           *mut ::std::os::raw::c_void)
                                           -> ::std::os::raw::c_int>;
pub type lua_Alloc =
::std::option::Option<unsafe extern "C" fn(ud:
                                           *mut ::std::os::raw::c_void,
                                           ptr:
                                           *mut ::std::os::raw::c_void,
                                           osize: size_t, nsize: size_t)
                                           -> *mut ::std::os::raw::c_void>;
pub type lua_Number = f64;
pub type lua_Integer = ptrdiff_t;
pub type lua_Hook =
::std::option::Option<unsafe extern "C" fn(L: *mut lua_State,
                                           ar: *mut lua_Debug)>;

#[repr(C)]
#[derive(Copy)]
pub struct lua_Debug {
    pub event: ::std::os::raw::c_int,
    pub name: *const ::std::os::raw::c_char,
    pub namewhat: *const ::std::os::raw::c_char,
    pub what: *const ::std::os::raw::c_char,
    pub source: *const ::std::os::raw::c_char,
    pub currentline: ::std::os::raw::c_int,
    pub nups: ::std::os::raw::c_int,
    pub linedefined: ::std::os::raw::c_int,
    pub lastlinedefined: ::std::os::raw::c_int,
    pub short_src: [::std::os::raw::c_char; 60usize],
    pub i_ci: ::std::os::raw::c_int,
}

impl ::std::clone::Clone for lua_Debug {
    fn clone(&self) -> Self { *self }
}

impl ::std::default::Default for lua_Debug {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

#[derive(Copy, Clone)]
#[repr(i32)]
#[derive(Debug)]
pub enum LuaJITMode {
    LUAJIT_MODE_ENGINE = 0,
    LUAJIT_MODE_DEBUG = 1,
    LUAJIT_MODE_FUNC = 2,
    LUAJIT_MODE_ALLFUNC = 3,
    LUAJIT_MODE_ALLSUBFUNC = 4,
    LUAJIT_MODE_TRACE = 5,
    LUAJIT_MODE_WRAPCFUNC = 16,
    LUAJIT_MODE_MAX = 17,
}

pub type luaJIT_profile_callback =
::std::option::Option<unsafe extern "C" fn(data:
                                           *mut ::std::os::raw::c_void,
                                           L: *mut lua_State,
                                           samples: ::std::os::raw::c_int,
                                           vmstate:
                                           ::std::os::raw::c_int)>;

#[repr(C)]
#[derive(Copy, Clone)]
#[derive(Debug)]
pub struct luaL_Reg {
    pub name: *const ::std::os::raw::c_char,
    pub func: lua_CFunction,
}

impl ::std::default::Default for luaL_Reg {
    fn default() -> Self { unsafe { ::std::mem::zeroed() } }
}

extern "C" {
    pub static mut __security_cookie: uintptr_t;
}

extern "C" {
    pub fn __va_start(arg1: *mut va_list, ...);
    pub fn __security_init_cookie();
    pub fn __security_check_cookie(_StackCookie: uintptr_t);
    pub fn __report_gsfailure(_StackCookie: uintptr_t);
    pub fn lua_newstate(f: lua_Alloc, ud: *mut ::std::os::raw::c_void)
                        -> *mut lua_State;
    pub fn lua_close(L: *mut lua_State);
    pub fn lua_newthread(L: *mut lua_State) -> *mut lua_State;
    pub fn lua_atpanic(L: *mut lua_State, panicf: lua_CFunction)
                       -> lua_CFunction;
    pub fn lua_gettop(L: *mut lua_State) -> ::std::os::raw::c_int;
    pub fn lua_settop(L: *mut lua_State, idx: ::std::os::raw::c_int);
    pub fn lua_pushvalue(L: *mut lua_State, idx: ::std::os::raw::c_int);
    pub fn lua_remove(L: *mut lua_State, idx: ::std::os::raw::c_int);
    pub fn lua_insert(L: *mut lua_State, idx: ::std::os::raw::c_int);
    pub fn lua_replace(L: *mut lua_State, idx: ::std::os::raw::c_int);
    pub fn lua_checkstack(L: *mut lua_State, sz: ::std::os::raw::c_int)
                          -> ::std::os::raw::c_int;
    pub fn lua_xmove(from: *mut lua_State, to: *mut lua_State,
                     n: ::std::os::raw::c_int);
    pub fn lua_isnumber(L: *mut lua_State, idx: ::std::os::raw::c_int)
                        -> ::std::os::raw::c_int;
    pub fn lua_isstring(L: *mut lua_State, idx: ::std::os::raw::c_int)
                        -> ::std::os::raw::c_int;
    pub fn lua_iscfunction(L: *mut lua_State, idx: ::std::os::raw::c_int)
                           -> ::std::os::raw::c_int;
    pub fn lua_isuserdata(L: *mut lua_State, idx: ::std::os::raw::c_int)
                          -> ::std::os::raw::c_int;
    pub fn lua_type(L: *mut lua_State, idx: ::std::os::raw::c_int)
                    -> ::std::os::raw::c_int;
    pub fn lua_typename(L: *mut lua_State, tp: ::std::os::raw::c_int)
                        -> *const ::std::os::raw::c_char;
    pub fn lua_equal(L: *mut lua_State, idx1: ::std::os::raw::c_int,
                     idx2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn lua_rawequal(L: *mut lua_State, idx1: ::std::os::raw::c_int,
                        idx2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn lua_lessthan(L: *mut lua_State, idx1: ::std::os::raw::c_int,
                        idx2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn lua_tonumber(L: *mut lua_State, idx: ::std::os::raw::c_int)
                        -> lua_Number;
    pub fn lua_tointeger(L: *mut lua_State, idx: ::std::os::raw::c_int)
                         -> lua_Integer;
    pub fn lua_toboolean(L: *mut lua_State, idx: ::std::os::raw::c_int)
                         -> ::std::os::raw::c_int;
    pub fn lua_tolstring(L: *mut lua_State, idx: ::std::os::raw::c_int,
                         len: *mut size_t) -> *const ::std::os::raw::c_char;
    pub fn lua_objlen(L: *mut lua_State, idx: ::std::os::raw::c_int)
                      -> size_t;
    pub fn lua_tocfunction(L: *mut lua_State, idx: ::std::os::raw::c_int)
                           -> lua_CFunction;
    pub fn lua_touserdata(L: *mut lua_State, idx: ::std::os::raw::c_int)
                          -> *mut ::std::os::raw::c_void;
    pub fn lua_tothread(L: *mut lua_State, idx: ::std::os::raw::c_int)
                        -> *mut lua_State;
    pub fn lua_topointer(L: *mut lua_State, idx: ::std::os::raw::c_int)
                         -> *const ::std::os::raw::c_void;
    pub fn lua_pushnil(L: *mut lua_State);
    pub fn lua_pushnumber(L: *mut lua_State, n: lua_Number);
    pub fn lua_pushinteger(L: *mut lua_State, n: lua_Integer);
    pub fn lua_pushlstring(L: *mut lua_State,
                           s: *const ::std::os::raw::c_char, l: size_t);
    pub fn lua_pushstring(L: *mut lua_State,
                          s: *const ::std::os::raw::c_char);
    pub fn lua_pushvfstring(L: *mut lua_State,
                            fmt: *const ::std::os::raw::c_char, argp: va_list)
                            -> *const ::std::os::raw::c_char;
    pub fn lua_pushfstring(L: *mut lua_State,
                           fmt: *const ::std::os::raw::c_char, ...)
                           -> *const ::std::os::raw::c_char;
    pub fn lua_pushcclosure(L: *mut lua_State, fn_: lua_CFunction,
                            n: ::std::os::raw::c_int);
    pub fn lua_pushboolean(L: *mut lua_State, b: ::std::os::raw::c_int);
    pub fn lua_pushlightuserdata(L: *mut lua_State,
                                 p: *mut ::std::os::raw::c_void);
    pub fn lua_pushthread(L: *mut lua_State) -> ::std::os::raw::c_int;
    pub fn lua_gettable(L: *mut lua_State, idx: ::std::os::raw::c_int);
    pub fn lua_getfield(L: *mut lua_State, idx: ::std::os::raw::c_int,
                        k: *const ::std::os::raw::c_char);
    pub fn lua_rawget(L: *mut lua_State, idx: ::std::os::raw::c_int);
    pub fn lua_rawgeti(L: *mut lua_State, idx: ::std::os::raw::c_int,
                       n: ::std::os::raw::c_int);
    pub fn lua_createtable(L: *mut lua_State, narr: ::std::os::raw::c_int,
                           nrec: ::std::os::raw::c_int);
    pub fn lua_newuserdata(L: *mut lua_State, sz: size_t)
                           -> *mut ::std::os::raw::c_void;
    pub fn lua_getmetatable(L: *mut lua_State,
                            objindex: ::std::os::raw::c_int)
                            -> ::std::os::raw::c_int;
    pub fn lua_getfenv(L: *mut lua_State, idx: ::std::os::raw::c_int);
    pub fn lua_settable(L: *mut lua_State, idx: ::std::os::raw::c_int);
    pub fn lua_setfield(L: *mut lua_State, idx: ::std::os::raw::c_int,
                        k: *const ::std::os::raw::c_char);
    pub fn lua_rawset(L: *mut lua_State, idx: ::std::os::raw::c_int);
    pub fn lua_rawseti(L: *mut lua_State, idx: ::std::os::raw::c_int,
                       n: ::std::os::raw::c_int);
    pub fn lua_setmetatable(L: *mut lua_State,
                            objindex: ::std::os::raw::c_int)
                            -> ::std::os::raw::c_int;
    pub fn lua_setfenv(L: *mut lua_State, idx: ::std::os::raw::c_int)
                       -> ::std::os::raw::c_int;
    pub fn lua_call(L: *mut lua_State, nargs: ::std::os::raw::c_int,
                    nresults: ::std::os::raw::c_int);
    pub fn lua_pcall(L: *mut lua_State, nargs: ::std::os::raw::c_int,
                     nresults: ::std::os::raw::c_int,
                     errfunc: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn lua_cpcall(L: *mut lua_State, func: lua_CFunction,
                      ud: *mut ::std::os::raw::c_void)
                      -> ::std::os::raw::c_int;
    pub fn lua_load(L: *mut lua_State, reader: lua_Reader,
                    dt: *mut ::std::os::raw::c_void,
                    chunkname: *const ::std::os::raw::c_char)
                    -> ::std::os::raw::c_int;
    pub fn lua_dump(L: *mut lua_State, writer: lua_Writer,
                    data: *mut ::std::os::raw::c_void)
                    -> ::std::os::raw::c_int;
    pub fn lua_yield(L: *mut lua_State, nresults: ::std::os::raw::c_int)
                     -> ::std::os::raw::c_int;
    pub fn lua_resume(L: *mut lua_State, narg: ::std::os::raw::c_int)
                      -> ::std::os::raw::c_int;
    pub fn lua_status(L: *mut lua_State) -> ::std::os::raw::c_int;
    pub fn lua_gc(L: *mut lua_State, what: ::std::os::raw::c_int,
                  data: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn lua_error(L: *mut lua_State) -> ::std::os::raw::c_int;
    pub fn lua_next(L: *mut lua_State, idx: ::std::os::raw::c_int)
                    -> ::std::os::raw::c_int;
    pub fn lua_concat(L: *mut lua_State, n: ::std::os::raw::c_int);
    pub fn lua_getallocf(L: *mut lua_State,
                         ud: *mut *mut ::std::os::raw::c_void) -> lua_Alloc;
    pub fn lua_setallocf(L: *mut lua_State, f: lua_Alloc,
                         ud: *mut ::std::os::raw::c_void);
    pub fn lua_setlevel(from: *mut lua_State, to: *mut lua_State);
    pub fn lua_getstack(L: *mut lua_State, level: ::std::os::raw::c_int,
                        ar: *mut lua_Debug) -> ::std::os::raw::c_int;
    pub fn lua_getinfo(L: *mut lua_State, what: *const ::std::os::raw::c_char,
                       ar: *mut lua_Debug) -> ::std::os::raw::c_int;
    pub fn lua_getlocal(L: *mut lua_State, ar: *const lua_Debug,
                        n: ::std::os::raw::c_int)
                        -> *const ::std::os::raw::c_char;
    pub fn lua_setlocal(L: *mut lua_State, ar: *const lua_Debug,
                        n: ::std::os::raw::c_int)
                        -> *const ::std::os::raw::c_char;
    pub fn lua_getupvalue(L: *mut lua_State, funcindex: ::std::os::raw::c_int,
                          n: ::std::os::raw::c_int)
                          -> *const ::std::os::raw::c_char;
    pub fn lua_setupvalue(L: *mut lua_State, funcindex: ::std::os::raw::c_int,
                          n: ::std::os::raw::c_int)
                          -> *const ::std::os::raw::c_char;
    pub fn lua_sethook(L: *mut lua_State, func: lua_Hook,
                       mask: ::std::os::raw::c_int,
                       count: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
    pub fn lua_gethook(L: *mut lua_State) -> lua_Hook;
    pub fn lua_gethookmask(L: *mut lua_State) -> ::std::os::raw::c_int;
    pub fn lua_gethookcount(L: *mut lua_State) -> ::std::os::raw::c_int;
    pub fn lua_upvalueid(L: *mut lua_State, idx: ::std::os::raw::c_int,
                         n: ::std::os::raw::c_int)
                         -> *mut ::std::os::raw::c_void;
    pub fn lua_upvaluejoin(L: *mut lua_State, idx1: ::std::os::raw::c_int,
                           n1: ::std::os::raw::c_int,
                           idx2: ::std::os::raw::c_int,
                           n2: ::std::os::raw::c_int);
    pub fn lua_loadx(L: *mut lua_State, reader: lua_Reader,
                     dt: *mut ::std::os::raw::c_void,
                     chunkname: *const ::std::os::raw::c_char,
                     mode: *const ::std::os::raw::c_char)
                     -> ::std::os::raw::c_int;
    pub fn luaJIT_setmode(L: *mut lua_State, idx: ::std::os::raw::c_int,
                          mode: ::std::os::raw::c_int)
                          -> ::std::os::raw::c_int;
    pub fn luaJIT_profile_start(L: *mut lua_State,
                                mode: *const ::std::os::raw::c_char,
                                cb: luaJIT_profile_callback,
                                data: *mut ::std::os::raw::c_void);
    pub fn luaJIT_profile_stop(L: *mut lua_State);
    pub fn luaJIT_profile_dumpstack(L: *mut lua_State,
                                    fmt: *const ::std::os::raw::c_char,
                                    depth: ::std::os::raw::c_int,
                                    len: *mut size_t)
                                    -> *const ::std::os::raw::c_char;
    pub fn luaJIT_version_2_1_0_beta2();
    pub fn luaopen_base(L: *mut lua_State) -> ::std::os::raw::c_int;
    pub fn luaopen_math(L: *mut lua_State) -> ::std::os::raw::c_int;
    pub fn luaopen_string(L: *mut lua_State) -> ::std::os::raw::c_int;
    pub fn luaopen_table(L: *mut lua_State) -> ::std::os::raw::c_int;
    pub fn luaopen_io(L: *mut lua_State) -> ::std::os::raw::c_int;
    pub fn luaopen_os(L: *mut lua_State) -> ::std::os::raw::c_int;
    pub fn luaopen_package(L: *mut lua_State) -> ::std::os::raw::c_int;
    pub fn luaopen_debug(L: *mut lua_State) -> ::std::os::raw::c_int;
    pub fn luaopen_bit(L: *mut lua_State) -> ::std::os::raw::c_int;
    pub fn luaopen_jit(L: *mut lua_State) -> ::std::os::raw::c_int;
    pub fn luaopen_ffi(L: *mut lua_State) -> ::std::os::raw::c_int;
    pub fn luaL_openlibs(L: *mut lua_State);
    pub fn luaL_openlib(L: *mut lua_State,
                        libname: *const ::std::os::raw::c_char,
                        l: *const luaL_Reg, nup: ::std::os::raw::c_int);
    pub fn luaL_register(L: *mut lua_State,
                         libname: *const ::std::os::raw::c_char,
                         l: *const luaL_Reg);
    pub fn luaL_getmetafield(L: *mut lua_State, obj: ::std::os::raw::c_int,
                             e: *const ::std::os::raw::c_char)
                             -> ::std::os::raw::c_int;
    pub fn luaL_callmeta(L: *mut lua_State, obj: ::std::os::raw::c_int,
                         e: *const ::std::os::raw::c_char)
                         -> ::std::os::raw::c_int;
    pub fn luaL_typerror(L: *mut lua_State, narg: ::std::os::raw::c_int,
                         tname: *const ::std::os::raw::c_char)
                         -> ::std::os::raw::c_int;
    pub fn luaL_argerror(L: *mut lua_State, numarg: ::std::os::raw::c_int,
                         extramsg: *const ::std::os::raw::c_char)
                         -> ::std::os::raw::c_int;
    pub fn luaL_checklstring(L: *mut lua_State, numArg: ::std::os::raw::c_int,
                             l: *mut size_t) -> *const ::std::os::raw::c_char;
    pub fn luaL_optlstring(L: *mut lua_State, numArg: ::std::os::raw::c_int,
                           def: *const ::std::os::raw::c_char, l: *mut size_t)
                           -> *const ::std::os::raw::c_char;
    pub fn luaL_checknumber(L: *mut lua_State, numArg: ::std::os::raw::c_int)
                            -> lua_Number;
    pub fn luaL_optnumber(L: *mut lua_State, nArg: ::std::os::raw::c_int,
                          def: lua_Number) -> lua_Number;
    pub fn luaL_checkinteger(L: *mut lua_State, numArg: ::std::os::raw::c_int)
                             -> lua_Integer;
    pub fn luaL_optinteger(L: *mut lua_State, nArg: ::std::os::raw::c_int,
                           def: lua_Integer) -> lua_Integer;
    pub fn luaL_checkstack(L: *mut lua_State, sz: ::std::os::raw::c_int,
                           msg: *const ::std::os::raw::c_char);
    pub fn luaL_checktype(L: *mut lua_State, narg: ::std::os::raw::c_int,
                          t: ::std::os::raw::c_int);
    pub fn luaL_checkany(L: *mut lua_State, narg: ::std::os::raw::c_int);
    pub fn luaL_newmetatable(L: *mut lua_State,
                             tname: *const ::std::os::raw::c_char)
                             -> ::std::os::raw::c_int;
    pub fn luaL_checkudata(L: *mut lua_State, ud: ::std::os::raw::c_int,
                           tname: *const ::std::os::raw::c_char)
                           -> *mut ::std::os::raw::c_void;
    pub fn luaL_where(L: *mut lua_State, lvl: ::std::os::raw::c_int);
    pub fn luaL_error(L: *mut lua_State,
                      fmt: *const ::std::os::raw::c_char, ...)
                      -> ::std::os::raw::c_int;
    pub fn luaL_checkoption(L: *mut lua_State, narg: ::std::os::raw::c_int,
                            def: *const ::std::os::raw::c_char,
                            lst: *mut *const ::std::os::raw::c_char)
                            -> ::std::os::raw::c_int;
    pub fn luaL_ref(L: *mut lua_State, t: ::std::os::raw::c_int)
                    -> ::std::os::raw::c_int;
    pub fn luaL_unref(L: *mut lua_State, t: ::std::os::raw::c_int,
                      ref_: ::std::os::raw::c_int);
    pub fn luaL_loadfile(L: *mut lua_State,
                         filename: *const ::std::os::raw::c_char)
                         -> ::std::os::raw::c_int;
    pub fn luaL_loadbuffer(L: *mut lua_State,
                           buff: *const ::std::os::raw::c_char, sz: size_t,
                           name: *const ::std::os::raw::c_char)
                           -> ::std::os::raw::c_int;
    pub fn luaL_loadstring(L: *mut lua_State,
                           s: *const ::std::os::raw::c_char)
                           -> ::std::os::raw::c_int;
    pub fn luaL_newstate() -> *mut lua_State;
    pub fn luaL_gsub(L: *mut lua_State, s: *const ::std::os::raw::c_char,
                     p: *const ::std::os::raw::c_char,
                     r: *const ::std::os::raw::c_char)
                     -> *const ::std::os::raw::c_char;
    pub fn luaL_findtable(L: *mut lua_State, idx: ::std::os::raw::c_int,
                          fname: *const ::std::os::raw::c_char,
                          szhint: ::std::os::raw::c_int)
                          -> *const ::std::os::raw::c_char;
    pub fn luaL_fileresult(L: *mut lua_State, stat: ::std::os::raw::c_int,
                           fname: *const ::std::os::raw::c_char)
                           -> ::std::os::raw::c_int;
    pub fn luaL_execresult(L: *mut lua_State, stat: ::std::os::raw::c_int)
                           -> ::std::os::raw::c_int;
    pub fn luaL_loadfilex(L: *mut lua_State,
                          filename: *const ::std::os::raw::c_char,
                          mode: *const ::std::os::raw::c_char)
                          -> ::std::os::raw::c_int;
    pub fn luaL_loadbufferx(L: *mut lua_State,
                            buff: *const ::std::os::raw::c_char, sz: size_t,
                            name: *const ::std::os::raw::c_char,
                            mode: *const ::std::os::raw::c_char)
                            -> ::std::os::raw::c_int;
    pub fn luaL_traceback(L: *mut lua_State, L1: *mut lua_State,
                          msg: *const ::std::os::raw::c_char,
                          level: ::std::os::raw::c_int);
}
